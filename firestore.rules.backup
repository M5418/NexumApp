rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {
    // Helper functions
    function signedIn() { 
      return request.auth != null; 
    }
    
    function isOwner(uid) { 
      return signedIn() && request.auth.uid == uid; 
    }
    
    function hasRole(role) {
      return signedIn() && request.auth.token[role] == true;
    }
    
    function isAdmin() {
      return hasRole('admin');
    }
    
    // User profiles
    match /users/{uid} {
      allow read: if true;                       // Public profiles
      allow create: if isOwner(uid);             // User creates own profile
      allow update: if isOwner(uid) || isAdmin(); // User or admin can update
      allow delete: if isOwner(uid) || isAdmin(); // User or admin can delete
      
      // User notifications subcollection
      match /notifications/{notifId} {
        allow read: if isOwner(uid);
        allow create: if signedIn();             // Usually via Functions
        allow update: if isOwner(uid);
        allow delete: if isOwner(uid);
      }
    }
    
    // Posts
    match /posts/{postId} {
      allow read: if true;                       // Public posts
      // Ensure the creating user is the author of the post
      allow create: if signedIn() &&
        request.resource.data.authorId == request.auth.uid;
      allow update: if signedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
      allow delete: if signedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
      
      // Post likes subcollection
      match /likes/{likeId} {
        allow read: if true;
        // Users can only like as themselves, and only set createdAt
        allow create: if signedIn() &&
          likeId == request.auth.uid &&
          request.resource.data.keys().hasOnly(['createdAt']);
        // Users can only remove their own like document
        allow delete: if signedIn() && likeId == request.auth.uid;
      }
      
      // Post bookmarks subcollection
      match /bookmarks/{bookmarkId} {
        allow read: if signedIn();
        // Users can only bookmark as themselves, and only set createdAt
        allow create: if signedIn() &&
          bookmarkId == request.auth.uid &&
          request.resource.data.keys().hasOnly(['createdAt']);
        // Users can only remove their own bookmark document
        allow delete: if signedIn() && bookmarkId == request.auth.uid;
      }
    }
    
    // Community Posts (separate collection for posts within communities)
    match /community_posts/{postId} {
      allow read: if true;                       // Public community posts
      // Ensure the creating user is the author and communityId is provided
      allow create: if signedIn() &&
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.communityId != null;
      allow update: if signedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
      allow delete: if signedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
      
      // Community post likes subcollection
      match /likes/{likeId} {
        allow read: if true;
        // Users can only like as themselves, and only set createdAt
        allow create: if signedIn() &&
          likeId == request.auth.uid &&
          request.resource.data.keys().hasOnly(['createdAt']);
        // Users can only remove their own like document
        allow delete: if signedIn() && likeId == request.auth.uid;
      }
      
      // Community post bookmarks subcollection
      match /bookmarks/{bookmarkId} {
        allow read: if signedIn();
        // Users can only bookmark as themselves, and only set createdAt
        allow create: if signedIn() &&
          bookmarkId == request.auth.uid &&
          request.resource.data.keys().hasOnly(['createdAt']);
        // Users can only remove their own bookmark document
        allow delete: if signedIn() && bookmarkId == request.auth.uid;
      }
    }
    
    // Comments
    match /comments/{commentId} {
      allow read: if true;                       // Public comments
      allow create: if signedIn();
      allow update: if signedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
      allow delete: if signedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
      
      // Comment likes subcollection
      match /likes/{likeId} {
        allow read: if true;
        allow create: if signedIn();
        allow delete: if signedIn();
      }
    }
    
    // Follows
    match /follows/{id} {
      allow read: if true;                       // Public follow relationships
      allow create: if signedIn();
      allow delete: if signedIn();
      allow update: if signedIn();
    }
    
    // Invitations
    match /invitations/{invitationId} {
      allow read: if signedIn();
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
    }
    
    // Conversations
    match /conversations/{conversationId} {
      allow read: if signedIn();
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
      
      // Conversation messages subcollection
      match /messages/{msgId} {
        allow read: if signedIn();
        allow create: if signedIn();
        allow update: if signedIn();
        allow delete: if signedIn();
      }
    }
    
    // Communities
    match /communities/{communityId} {
      allow read: if true;                       // Public communities
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if isAdmin();
      
      // Community members subcollection
      match /members/{memberId} {
        allow read: if true;
        allow create: if signedIn();
        allow update: if signedIn();
        allow delete: if signedIn();
      }
    }
    
    // CollectionGroup query support for community members  
    // Must match or be more permissive than subcollection rule
    match /{path=**}/members/{memberId} {
      allow read: if true;                       // Public read to match subcollection rule
    }
    
    // CollectionGroup query support for likes
    // Allows querying all likes across all posts (used for Activity tab)
    match /{path=**}/likes/{likeId} {
      allow read: if signedIn();                 // Authenticated users can read likes
      allow create: if signedIn() && likeId == request.auth.uid;
      allow delete: if signedIn() && likeId == request.auth.uid;
    }
    
    // CollectionGroup query support for bookmarks
    // Allows querying all bookmarks across all posts (used for Activity tab)
    match /{path=**}/bookmarks/{bookmarkId} {
      allow read: if signedIn();                 // Authenticated users can read bookmarks
      allow create: if signedIn() && bookmarkId == request.auth.uid;
      allow delete: if signedIn() && bookmarkId == request.auth.uid;
    }
    
    // Stories
    match /stories/{storyId} {
      allow read: if true;
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();

      // Story replies subcollection (comments on stories)
      match /replies/{replyId} {
        allow read: if true;
        // Only authenticated users can create a reply; userId must match
        allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
        // No updates; delete allowed only by author or admin
        allow update: if false;
        allow delete: if signedIn() && (request.auth.uid == resource.data.userId || isAdmin());
      }
    }
    
    // Story rings
    match /story_rings/{ringId} {
      allow read: if true;
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
    }
    
    // Books
    match /books/{bookId} {
      allow read: if true;
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if isAdmin();
    }
    
    // Book categories
    match /book_categories/{categoryId} {
      allow read: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Book progress
    match /book_progress/{progressId} {
      allow read: if signedIn();
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
    }
    
    // Podcasts
    match /podcasts/{podcastId} {
      allow read: if true;
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if isAdmin();
    }
    
    // Podcast categories
    match /podcast_categories/{categoryId} {
      allow read: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Podcast progress
    match /podcast_progress/{progressId} {
      allow read: if signedIn();
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
    }
    
    // Mentors
    match /mentors/{mentorId} {
      allow read: if true;
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
    }
    
    // Mentorship conversations
    match /mentorship_conversations/{conversationId} {
      allow read: if signedIn();
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
    }
    
    // Mentorship fields
    match /mentorship_fields/{fieldId} {
      allow read: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Mentorship requests
    match /mentorship_requests/{requestId} {
      allow read: if signedIn();
      allow create: if signedIn();
      allow update: if signedIn();
      allow delete: if signedIn();
    }
    
    // Reports
    match /reports/{reportId} {
      allow read: if isAdmin();
      allow create: if signedIn();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // KYC requests
    match /kyc_requests/{kycId} {
      allow read: if signedIn() && (isOwner(resource.data.userId) || isAdmin());
      allow create: if signedIn();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Blocks
    match /blocks/{blockId} {
      allow read: if signedIn() && 
        (request.auth.uid == resource.data.blockedByUid || isAdmin());
      allow create: if signedIn() && request.auth.uid == request.resource.data.blockedByUid;
      allow delete: if signedIn() && 
        (request.auth.uid == resource.data.blockedByUid || isAdmin());
    }
    
    // Mutes
    match /mutes/{muteId} {
      allow read: if signedIn() && 
        (request.auth.uid == resource.data.mutedByUid || isAdmin());
      allow create: if signedIn() && request.auth.uid == request.resource.data.mutedByUid;
      allow delete: if signedIn() && 
        (request.auth.uid == resource.data.mutedByUid || isAdmin());
    }
    
    // Bookmarks (top-level collection for posts, podcasts, books)
    match /bookmarks/{bookmarkId} {
      allow read: if signedIn() && 
        (request.auth.uid == resource.data.userId || isAdmin());
      allow create: if signedIn() && 
        request.auth.uid == request.resource.data.userId &&
        request.resource.data.keys().hasAll(['userId', 'type', 'itemId', 'createdAt']) &&
        request.resource.data.type in ['post', 'podcast', 'book'];
      allow update: if false; // Bookmarks are immutable (create or delete only)
      allow delete: if signedIn() && 
        (request.auth.uid == resource.data.userId || isAdmin());
    }
    
    // Drafts (for posts and podcasts)
    match /drafts/{draftId} {
      allow read: if signedIn() && 
        (request.auth.uid == resource.data.userId || isAdmin());
      allow create: if signedIn() && 
        request.auth.uid == request.resource.data.userId &&
        request.resource.data.keys().hasAll(['userId', 'type', 'title', 'body', 'createdAt', 'updatedAt']) &&
        request.resource.data.type in ['post', 'podcast'];
      allow update: if signedIn() && 
        (request.auth.uid == resource.data.userId || isAdmin()) &&
        request.resource.data.userId == resource.data.userId; // Cannot change owner
      allow delete: if signedIn() && 
        (request.auth.uid == resource.data.userId || isAdmin());
    }
    
    // Support tickets
    match /support_tickets/{ticketId} {
      allow read: if signedIn() && 
        (request.auth.uid == resource.data.userId || isAdmin());
      allow create: if signedIn() && 
        request.auth.uid == request.resource.data.userId;
      allow update: if isAdmin(); // Only admin can update (respond to) tickets
      allow delete: if isAdmin();
    }
    
    // Podcast playlists
    match /podcast_playlists/{playlistId} {
      // Allow users to read their own playlists
      allow read: if signedIn() && request.auth.uid == resource.data.userId;
      
      // Allow users to create playlists (userId must match their own)
      allow create: if signedIn() && 
        request.auth.uid == request.resource.data.userId &&
        request.resource.data.keys().hasAll(['name', 'userId', 'isPrivate', 'podcastIds', 'createdAt', 'updatedAt']);
      
      // Allow users to update their own playlists (cannot change owner)
      allow update: if signedIn() && 
        request.auth.uid == resource.data.userId &&
        request.resource.data.userId == resource.data.userId;
      
      // Allow users to delete their own playlists
      allow delete: if signedIn() && request.auth.uid == resource.data.userId;
    }
  }
}
